/**
 * @license MIT
 * Copyright (c) 2025 SGNL.ai, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
"use strict";async function e(e){const s=e.environment||{},o=e.secrets||{};if(o.BEARER_AUTH_TOKEN){const e=o.BEARER_AUTH_TOKEN;return e.startsWith("Bearer ")?e:`Bearer ${e}`}if(o.BASIC_PASSWORD&&o.BASIC_USERNAME){return`Basic ${btoa(`${o.BASIC_USERNAME}:${o.BASIC_PASSWORD}`)}`}if(o.OAUTH2_AUTHORIZATION_CODE_ACCESS_TOKEN){const e=o.OAUTH2_AUTHORIZATION_CODE_ACCESS_TOKEN;return e.startsWith("Bearer ")?e:`Bearer ${e}`}if(o.OAUTH2_CLIENT_CREDENTIALS_CLIENT_SECRET){const e=s.OAUTH2_CLIENT_CREDENTIALS_TOKEN_URL,t=s.OAUTH2_CLIENT_CREDENTIALS_CLIENT_ID,n=o.OAUTH2_CLIENT_CREDENTIALS_CLIENT_SECRET;if(!e||!t)throw new Error("OAuth2 Client Credentials flow requires TOKEN_URL and CLIENT_ID in env");const r=await async function(e){const{tokenUrl:s,clientId:o,clientSecret:t,scope:n,audience:r,authStyle:a}=e;if(!s||!o||!t)throw new Error("OAuth2 Client Credentials flow requires tokenUrl, clientId, and clientSecret");const c=new URLSearchParams;c.append("grant_type","client_credentials"),n&&c.append("scope",n),r&&c.append("audience",r);const i={"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"};if("InParams"===a)c.append("client_id",o),c.append("client_secret",t);else{const e=btoa(`${o}:${t}`);i.Authorization=`Basic ${e}`}const E=await fetch(s,{method:"POST",headers:i,body:c.toString()});if(!E.ok){let e;try{const s=await E.json();e=JSON.stringify(s)}catch{e=await E.text()}throw new Error(`OAuth2 token request failed: ${E.status} ${E.statusText} - ${e}`)}const u=await E.json();if(!u.access_token)throw new Error("No access_token in OAuth2 response");return u.access_token}({tokenUrl:e,clientId:t,clientSecret:n,scope:s.OAUTH2_CLIENT_CREDENTIALS_SCOPE,audience:s.OAUTH2_CLIENT_CREDENTIALS_AUDIENCE,authStyle:s.OAUTH2_CLIENT_CREDENTIALS_AUTH_STYLE});return`Bearer ${r}`}throw new Error("No authentication configured. Provide one of: BEARER_AUTH_TOKEN, BASIC_USERNAME/BASIC_PASSWORD, OAUTH2_AUTHORIZATION_CODE_ACCESS_TOKEN, or OAUTH2_CLIENT_CREDENTIALS_*")}async function s(e,s,o,t){const n=`${o}${e}`;return await fetch(n,{method:s,headers:{Authorization:t,Accept:"application/json","Content-Type":"application/json"}})}var o={invoke:async(o,t)=>{console.log("Starting Salesforce session revocation");const{username:n}=o,r=function(e,s){const o=s.environment||{},t=e?.address||o.ADDRESS;if(!t)throw new Error("No URL specified. Provide address parameter or ADDRESS environment variable");return t.endsWith("/")?t.slice(0,-1):t}(o,t),a=await e(t);console.log(`Processing username: ${n}`);try{const e=`/services/data/v61.0/query?q=SELECT+Id+FROM+User+WHERE+username+LIKE+'${encodeURIComponent(n)}'+ORDER+BY+Id+ASC`;console.log("Step 1: Querying for user ID...");const o=await s(e,"GET",r,a);if(!o.ok)throw new Error(`Failed to query user: ${o.status} ${o.statusText}`);const t=await o.json();if(!t.records||0===t.records.length)throw new Error(`User not found: ${n}`);const c=t.records[0].Id;console.log(`Found user ID: ${c}`);const i=`/services/data/v61.0/query?q=SELECT+Id,UsersId+FROM+AuthSession+WHERE+UsersId='${c}'+AND+IsCurrent=false+ORDER+BY+Id+ASC`;console.log("Step 2: Querying for user sessions...");const E=await s(i,"GET",r,a);if(!E.ok)throw new Error(`Failed to query sessions: ${E.status} ${E.statusText}`);const u=(await E.json()).records||[];if(console.log(`Found ${u.length} sessions to revoke`),0===u.length)return console.log("No sessions found to revoke"),{status:"success",username:n,userId:c,sessionsRevoked:0,processed_at:(new Date).toISOString(),address:r};console.log("Step 3: Revoking sessions...");let l=0;for(const e of u){const o=`/services/data/v61.0/sobjects/AuthSession/${e.Id}`;try{const t=await s(o,"DELETE",r,a);204===t.status||404===t.status||t.ok?(l++,console.log(`Successfully revoked session: ${e.Id}`)):console.warn(`Failed to revoke session ${e.Id}: ${t.status} ${t.statusText}`)}catch(s){console.warn(`Error revoking session ${e.Id}: ${s.message}`)}}return console.log(`Successfully revoked ${l} out of ${u.length} sessions`),{status:"success",username:n,userId:c,sessionsRevoked:l,processed_at:(new Date).toISOString(),address:r}}catch(e){throw console.error(`Failed to revoke sessions for user ${n}: ${e.message}`),e}},error:async(e,s)=>{const{error:o}=e;throw o},halt:async(e,s)=>{const{reason:o,username:t}=e;return console.log(`Session revocation is being halted (${o}) for user: ${t}`),console.log("Halting session revocation process - no cleanup needed"),{status:"halted",username:t||"unknown",reason:o,halted_at:(new Date).toISOString()}}};module.exports=o;
